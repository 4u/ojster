/*

TODO

- refactor - better overrides for goog and stuff

- use defaultsOptions for each option to expose defaults

optimize:
- pre-concat sequential string constants

*/

var Block = require('./block');
var Buffer = require('./buffer');
var tokens = require('../tokenizer/tokens');
var generationErrors = require('./generation_errors');

var strTools = require('../../tools/str_tools');
var objectTools = require('../../tools/object_tools');

var Generator = function(options, errors) {
	options = options || {};

	this.needCompactFragmentWhitespaces =
		options.compactFragmentWhitespaces === undefined ? true : options.compactFragmentWhitespaces;

	this.intro = options.intro === undefined ? Generator.defaultOptions.intro : options.intro;

	this.thisAlias = options.thisAlias || 'self';

	this.inheritsAlias = options.inheritsAlias || 'inherits';
	this.inheritsPath = options.inheritsPath || "'util'";
	this.inheritsSubpath = options.inheritsSubpath || 'inherits';
	this.inheritsFullName = options.inheritsFullName;

	this.indentStr = options.indentStr || '\t';
	this.appendFunctionStr = options.appendFunctionStr || 'writer.write';
	this.escapeFunctionStr = options.escapeFunctionStr || 'escape';
	this.getCssNameFunctionStr = options.getCssNameFunctionStr || 'getCssName';
	this.baseCssNamePropertyStr = options.baseCssNamePropertyStr || 'baseCssName';
	this.initFunctionStr = options.initFunctionStr || 'init';
	this.setFunctionStr = options.setFunctionStr || 'set';

	this.appendCssNamesLiterallyWhenPossible = options.appendCssNamesLiterallyWhenPossible === undefined ? false : !!options.appendCssNamesLiterallyWhenPossible;

	this.blockFunctionNamePrefixStr = options.blockFunctionNamePrefixStr || 'renderBlock';

	this.blockLocals = options.blockLocals || Generator.defaultOptions.blockLocals;

	this.nonBlockFragmentsAreCode =
		options.nonBlockFragmentsAreCode === undefined ? true : options.nonBlockFragmentsAreCode;

	if (options.appendLineNumbers !== undefined && !options.appendLineNumbers) {
		this.appendLineNumbersFor = {};
	} else {
		this.appendLineNumbersFor = objectTools.extend({
			require: false,
			template: false,
			inherits: false,
			block: true,
			blockClose: true,
			blockCall: true,
			templateInsertion: true,
			fragment: false,
			expression: true,
			sequenceClose: true,
			sequenceCloseBeforeBlockClose: false,
			oneLineCodeFragment: false
		}, options.appendLineNumbersFor);
	}

	// per file
	this.errors = errors;
	this.templates = [];
	this.requireInheritsBuffer = null;

	// per template
	this.templateAlias = null;
	this.templateFullName = null;
	this.templateNameToUse = null;

	this.templateBaseName = null;
	this.templateBaseFullName = null;
	this.templateBaseNameToUse = null;

	this.stack = [];
	this.currentBuffer = null;

	this.blockStack = [];
	this.currentBlock = null;

	this.definitionBuffer = null;
	this.definitionCtx = null;

	this.templateInfoSet = false;
	this.inheritsAdded = false;
	this.usedBlockNames = {};

	this.requirements = [];

	this.templateInfoMissedErrorReported = false;
	this.inheritanceInfoMissedErrorReported = false;

	this.initStack();
};

module.exports = Generator;

Generator.errors = generationErrors;

Generator.defaultOptions = {
	intro: '// Content below is autogenerated by ojster template engine\n// usually there is no reason to edit it manually\n',
	blockLocals: 'var d = this.data, vars = this.vars;'
};

Generator.prototype.error = function(err) {
	this.errors.push(err);
};

Generator.prototype.appendOnTemplateFinalize = function() {
	this.appendDefinition();
};

Generator.prototype.finalizeCurrentTemplate = function() {
	// TODO additional checks (stack, etc.)

	if (!this.templateInfoSet) {
		this.reportTemplateInfoMissedError();
		return;
	}
	if (!this.inheritsAdded) {
		this.reportInheritanceInfoMissedError();
		return;
	}

	this.appendOnTemplateFinalize();

	this.templateAlias = null;
	this.templateFullName = null;
	this.templateNameToUse = null;

	this.templateBaseName = null;
	this.templateBaseFullName = null;
	this.templateBaseNameToUse = null;

	this.definitionBuffer = null;
	this.definitionCtx = null;

	this.templateInfoSet = false;
	this.inheritsAdded = false;
	this.usedBlockNames = {};

	this.templateInfoMissedErrorReported = false;
	this.inheritanceInfoMissedErrorReported = false;
};

Generator.prototype.initStack = function() {
	this.appendIntro();
	this.requireInheritsBuffer = this.appendBuffer();
};

Generator.prototype.applyToken = function(token) {
	token.generatorAction(this);
};

Generator.prototype.appendIntro = function() {
	if (this.intro) {
		this.append(this.intro);
	}
};

Generator.prototype.appendRequire = function(ctx, alias, path, subpath, fullName, subname) {
	if (this.currentBlock) {
		this.error(new generationErrors.RequireWithinBlock(ctx));
		return;
	}

	this.appendRequireTo(this, ctx, alias, path, subpath, fullName);
	this.requirements.push({
		alias: alias,
		path: path,
		subpath: subpath,
		fullName: fullName,
		subname: subname
	});
};

Generator.prototype.appendRequireTo = function(buffer, ctx, alias, path, subpath, fullName) {
	buffer.append(
		'var ', alias, ' = require(', path, ')'
	);
	if (subpath) {
		buffer.append(
			'.', subpath
		);
	}
	buffer.append(';');

	if (ctx && this.appendLineNumbersFor.require) {
		this.appendLineNumberTo(buffer, ctx);
	}
};

Generator.prototype.appendInheritsRequire = function() {
	this.requireInheritsBuffer.append('\n');
	this.appendRequireTo(this.requireInheritsBuffer, null,
		this.inheritsAlias,
		this.inheritsPath,
		this.inheritsSubpath,
		this.inheritsFullName
	);
	this.requireInheritsBuffer.append('\n');
};

Generator.prototype.setTemplateInfo = function(ctx, templateAlias, templateFullName) {
	if (this.currentBlock) {
		this.error(new generationErrors.TemplateInfoWithinBlock(ctx));
		return;
	}
	if (this.templateInfoSet) {
		this.finalizeCurrentTemplate();
	}

	this.templateAlias = templateAlias;
	this.templateFullName = templateFullName;
	this.templateNameToUse = this.getTemplateNameToUse();
	this.appendDefinitionBuffer();
	this.definitionCtx = ctx;

	this.templates.push({
		name: this.templateAlias || this.templateFullName,
		reference: this.templateNameToUse
	});

	this.templateInfoSet = true;
};

Generator.prototype.appendDefinitionBuffer = function() {
	this.definitionBuffer = this.appendBuffer();
};

Generator.prototype.setInheritanceInfo = function(ctx, templateBaseName, templateBaseFullName) {
	if (this.currentBlock) {
		this.error(new generationErrors.InheritanceInfoWithinBlock(ctx));
		return;
	}
	if (this.inheritsAdded) {
		this.error(new generationErrors.DuplicateInheritanceInfo(ctx));
		return;
	}
	if (!this.templateInfoSet) {
		this.reportTemplateInfoMissedError(ctx);
		return;
	}

	this.templateBaseName = templateBaseName;
	this.templateBaseFullName = templateBaseFullName;
	this.templateBaseNameToUse = this.getTemplateBaseNameToUse();
	this.appendInherits(ctx);
	this.inheritsAdded = true;
};

Generator.prototype.appendSetInitializer = function(ctx, props) {
	if (this.currentBlock) {
		this.error(new generationErrors.SetInitializerWithinBlock(ctx));
		return;
	}

	this.appendFunctionDefinitionStartTo(this, ctx, this.initFunctionStr);
	this.appendBaseCallTo(this, ctx, this.initFunctionStr);
	this.append(
		'\n', this.indentStr, 'this.', this.setFunctionStr, '(', props, ');\n'
	);
	this.appendFunctionDefinitionEndTo(this, ctx);
};

Generator.prototype.appendFragment = function(ctx, fragment) {
	if (!fragment) {
		return;
	}

	if (!this.currentBlock) {
		if (this.nonBlockFragmentsAreCode) {
			this.appendCodeFragment(ctx, fragment, true);
			return;
		}

		if (!fragment.match(/\S/)) {
			return;
		}

		this.error(new generationErrors.FragmentBeyondBlock(ctx));
		return;
	}

	if (this.needCompactFragmentWhitespaces) {
		fragment = this.compactFragmentWhitespaces(fragment);
		if (!fragment) {
			return;
		}
	}

	this.appendToSequence("'", strTools.jsStringEscape(fragment), "'");

	this.lastSequenceCtx = this.appendLineNumbersFor.fragment ? ctx : null;
};

Generator.prototype.appendSpace = function(ctx) {
	if (!this.currentBlock) {
		this.error(new generationErrors.FragmentBeyondBlock(ctx));
		return;
	}

	this.appendToSequence("' '");
	this.lastSequenceCtx = this.appendLineNumbersFor.fragment ? ctx : null;
};

Generator.prototype.appendExpression = function(ctx, expression, toBeEscaped) {
	if (!this.currentBlock) {
		this.error(new generationErrors.ExpressionBeyondBlock(ctx));
		return;
	}

	if (expression.search(/[\r\n]/) == -1) {
		expression = expression.trim();
	}

	if (toBeEscaped) {
		this.appendToSequence(this.thisAlias, '.', this.escapeFunctionStr, '(', expression, ')');
	} else {
		this.appendToSequence(expression);
	}

	this.lastSequenceCtx = this.appendLineNumbersFor.expression ? ctx : null;
};

Generator.prototype.appendCodeFragment = function(ctx, code, fragmentAsCode) {
	if (this.currentBlock && !code.match(/\S/)) {
		return;
	}

	var buffer;
	if (this.currentBlock) {
		this.closeSequenceIfNeed(ctx);
		buffer = this.currentBlock;
	} else {
		buffer = this;
	}

	var oneLineInstruction = (!fragmentAsCode && code.search(/[\r\n]/) == -1);
	if (oneLineInstruction) {
		code = code.trim();
		if (this.currentBlock) {
			buffer.append('\n', this.indentStr);
		}
	} else if (!fragmentAsCode) {
		code = this.removeTrailingSpaces(code);
	}

	buffer.append(code);

	if (this.currentBlock) {
		if (oneLineInstruction) {
			if (ctx && this.appendLineNumbersFor.oneLineCodeFragment) {
				this.appendLineNumberTo(buffer, ctx);
			}
			buffer.append('\n');
		}
		buffer.append('\n');
	}
};

Generator.prototype.appendGetCssNameFunctionFullStr = function(buffer) {
	buffer.append(this.thisAlias, '.', this.getCssNameFunctionStr);
};

Generator.prototype.appendCssName = function(ctx, nameExpr, nameStr, modifiers) {
	if (!this.currentBlock) {
		this.error(new generationErrors.CssNameBeyondBlock(ctx));
		return;
	}

	this.openSequenceOrSeparateIfNeed();
	var buffer = this.currentBlock;
	if (nameExpr == null && nameStr == null && modifiers == null) {
		buffer.append(this.thisAlias, '.', this.baseCssNamePropertyStr);
	} else if (this.appendCssNamesLiterallyWhenPossible && nameStr != null) {
		buffer.append('\'', strTools.jsStringEscape(nameStr.trim()), '\'');
	} else {
		this.appendGetCssNameFunctionFullStr(buffer);
		buffer.append('(');
		if (nameStr != null) {
			buffer.append('\'', strTools.jsStringEscape(nameStr.trim()), '\'');
		} else {
			if (nameExpr == null) {
				buffer.append(this.thisAlias, '.', this.baseCssNamePropertyStr);
			} else {
				buffer.append(nameExpr.trim());
			}
			buffer.append(', \'', strTools.jsStringEscape(modifiers.trim()), '\'');
		}
		buffer.append(')');
	}
	this.currentBlock.sequenceEmpty = false;

	this.lastSequenceCtx = this.appendLineNumbersFor.expression ? ctx : null;
};

Generator.prototype.startBlock = function(ctx, blockName, blockArgs, closeImmediately) {
	if (blockName in this.usedBlockNames) {
		this.error(new generationErrors.DuplicateBlockName(ctx, blockName));
		return;
	}

	var buffer = this.createBuffer();
	var block = new Block(blockName, blockArgs, buffer);

	if (this.currentBlock) {
		this.appendBlockCall(ctx, blockName, blockArgs);
	}

	this.blockStack.push(block);
	this.currentBlock = block;

	this.appendToStack(block);

	this.appendBlockDefinitionStart(ctx);

	if (closeImmediately) {
		this.endBlock(null, blockName);
	}

	this.usedBlockNames[blockName] = true;
};

Generator.prototype.endBlock = function(ctx, blockName) {
	if (this.currentBlock == null || blockName != null && this.currentBlock.name != blockName) {
		this.error(new generationErrors.BlockOpeningMissed(ctx, blockName));
		return;
	}

	this.closeSequenceIfNeed(this.appendLineNumbersFor.sequenceCloseBeforeBlockClose ? ctx : null);
	this.appendBlockDefinitionEnd(ctx);

	this.blockStack.pop();
	this.currentBlock = this.blockStack[this.blockStack.length - 1];
};

Generator.prototype.appendToSequence = function() {
	this.openSequenceOrSeparateIfNeed();
	this.currentBlock.append.apply(this.currentBlock, arguments);
	this.currentBlock.sequenceEmpty = false;
};

Generator.prototype.appendBlockCall = function(ctx, blockName, args) {
	if (!this.currentBlock) {
		this.error(new generationErrors.BlockCallBeyondBlock(ctx));
		return;
	}

	this.closeSequenceIfNeed(ctx);
	if (blockName == '$base')
	{
		this.appendBlockBaseCall(ctx, args);
	}
	else
	{
		this.currentBlock.append(this.indentStr, this.thisAlias, '.', this.getBlockFunctionName(blockName), '(', args, ');');
	}

	if (ctx && this.appendLineNumbersFor.blockCall) {
		this.appendLineNumberTo(this.currentBlock, ctx);
	}

	this.currentBlock.append('\n');
};

Generator.prototype.appendBlockBaseCall = function(ctx, args) {
	var blockFuncName = this.getBlockFunctionName(this.currentBlock.name);
	this.appendBaseCallTo(this.currentBlock, ctx, blockFuncName, args, this.thisAlias);
};

Generator.prototype.appendBaseCallTo = function(buffer, ctx, funcName, args, thisStr) {
	if (!this.inheritsAdded) {
		this.reportInheritanceInfoMissedError(ctx);
		return;
	}

	if (thisStr == null) {
		thisStr = 'this';
	}

	var comma = (args && args != '' ? ', ' : null);
	buffer.append(
		this.indentStr,
		this.templateBaseNameToUse, '.prototype.', funcName,
		'.call(', thisStr, args, ');'
	);
};

Generator.prototype.appendTemplateInsertion = function(ctx, templateName, args) {
	if (!this.currentBlock) {
		this.error(new generationErrors.TemplateInsertionBeyondBlock(ctx));
		return;
	}

	this.closeSequenceIfNeed(ctx);
	this.currentBlock.append(this.indentStr, 'new ', templateName, '(', args, ').renderTo(', this.thisAlias,');');

	if (ctx && this.appendLineNumbersFor.templateInsertion) {
		this.appendLineNumberTo(this.currentBlock, ctx);
	}

	this.currentBlock.append('\n');
};

Generator.prototype.append = function() {
	if (this.currentBuffer == null) {
		this.currentBuffer = this.appendBuffer();
	}
	this.currentBuffer.append.apply(this.currentBuffer, arguments);
};

Generator.prototype.reportTemplateInfoMissedError = function(ctx) {
	if (!this.templateInfoMissedErrorReported) {
		this.error(new generationErrors.TemplateInfoMissed(ctx));
		this.templateInfoMissedErrorReported = true;
	}
};

Generator.prototype.reportInheritanceInfoMissedError = function(ctx) {
	if (!this.inheritanceInfoMissedErrorReported) {
		this.error(new generationErrors.InheritanceInfoMissed(ctx));
		this.inheritanceInfoMissedErrorReported = true;
	}
};

Generator.prototype.appendOnFinalize = function() {
	this.appendInheritsRequire();
	this.appendExports();
};

Generator.prototype.getResult = function() {
	this.finalizeCurrentTemplate();
	this.appendOnFinalize();
	this.append('\n'); // trailing \n

	var result = [];

	for (var i=0, l=this.stack.length; i<l; i++) {
		var item = this.stack[i];
		result.push(item.getValue());
	}

	return result.join('');
};

Generator.prototype.openSequenceOrSeparateIfNeed = function() {
	if (!this.currentBlock.sequenceOpened) {
		this.openSequence();
		this.currentBlock.sequenceOpened = true;
		this.currentBlock.sequenceEmpty = true;
	} else if (!this.currentBlock.sequenceEmpty) {
		this.separateSequence();
	}
};

Generator.prototype.closeSequenceIfNeed = function(ctx) {
	if (this.currentBlock.sequenceOpened) {
		this.closeSequence(ctx);
		this.currentBlock.sequenceOpened = false;
	}
};

Generator.prototype.appendDefinition = function() {
	this.definitionBuffer.append(
		'var ', this.templateNameToUse, ' = function() {'
	);

	if (this.definitionCtx && this.appendLineNumbersFor.template) {
		this.appendLineNumberTo(this.definitionBuffer, this.definitionCtx);
	}

	this.definitionBuffer.append(
		'\n',
		this.indentStr
	);
	this.appendSuperClassConstructorCall();
	this.definitionBuffer.append(
		'\n};'
	);
};

Generator.prototype.appendSuperClassConstructorCall = function() {
	this.definitionBuffer.append(
		this.templateBaseNameToUse, '.apply(this, arguments);'
	);
};

Generator.prototype.appendInherits = function(ctx) {
	this.append(
		this.inheritsAlias, '(', this.templateNameToUse, ', ', this.templateBaseNameToUse, ');'
	);

	if (ctx && this.appendLineNumbersFor.inherits) {
		this.appendLineNumberTo(this, ctx);
	}
};

Generator.prototype.appendExports = function() {
	if (this.templates.length == 1)
	{
		this.append(
			'\nmodule.exports = ', this.templates[0].reference, ';'
		);
	}
	else
	{
		this.append('\nmodule.exports = {\n');
		for (var i=0; i<this.templates.length; i++)
		{
			var template = this.templates[i];
			var prefix = (i>0 ? ',\n' : '');
			this.append(prefix, this.indentStr, template.name, ': ', template.reference);
		}
		this.append('\n};');
	}
};

Generator.prototype.openSequence = function() {
	this.currentBlock.append(
		this.indentStr, this.thisAlias, '.', this.appendFunctionStr, '(\n',
		this.indentStr, this.indentStr
	);
};

Generator.prototype.separateSequence = function() {
	this.currentBlock.append(',');

	if (this.lastSequenceCtx) {
		this.appendLineNumberTo(this.currentBlock, this.lastSequenceCtx);
	}

	this.currentBlock.append(
		'\n',
		this.indentStr, this.indentStr
	);
};

Generator.prototype.closeSequence = function(ctx) {
	if (this.lastSequenceCtx) {
		this.appendLineNumberTo(this.currentBlock, this.lastSequenceCtx);
	}

	this.currentBlock.append(
		'\n',
		this.indentStr, ');'
	);

	if (ctx && this.appendLineNumbersFor.sequenceClose) {
		this.appendLineNumberTo(this.currentBlock, ctx);
	}

	this.currentBlock.append('\n');
};

Generator.prototype.appendBlockDefinitionStart = function(ctx) {
	var funcName = this.getBlockFunctionName(this.currentBlock.name);
	var args = this.currentBlock.args;

	var prepend = null;
	if (this.blockStack.length > 1) {
		prepend = '\n\n';
	}

	this.appendFunctionDefinitionStartTo(this.currentBlock, ctx, funcName, args, prepend);
	this.appendBlockLocals();
};

Generator.prototype.appendFunctionDefinitionStartTo = function(buffer, ctx, funcName, args, prepend) {
	if (!this.templateInfoSet) {
		this.reportTemplateInfoMissedError(ctx);
		return;
	}

	if (prepend) {
		buffer.append(prepend);
	}

	if (!args) {
		args = '';
	}

	buffer.append(
		this.templateNameToUse, '.prototype.', funcName,
		' = function(', args, ') {'
	);

	if (ctx && this.appendLineNumbersFor.block) {
		this.appendLineNumberTo(buffer, ctx);
	}

	buffer.append('\n');
};

Generator.prototype.appendBlockLocals = function() {
	if (this.thisAlias && this.thisAlias != 'this') {
		this.currentBlock.append(this.indentStr, 'var ', this.thisAlias, ' = this;\n');
	}
	if (this.blockLocals) {
		this.currentBlock.append(this.indentStr, this.blockLocals, '\n');
	}
};

Generator.prototype.appendBlockDefinitionEnd = function(ctx) {
	this.appendFunctionDefinitionEndTo(this.currentBlock, ctx);
};

Generator.prototype.appendFunctionDefinitionEndTo = function(buffer, ctx) {
	buffer.append('};');

	if (ctx && this.appendLineNumbersFor.blockClose) {
		this.appendLineNumberTo(buffer, ctx);
	}
};

Generator.prototype.getTemplateNameToUse = function() {
	return this.templateAlias;
};

Generator.prototype.getTemplateBaseNameToUse = function() {
	return this.templateBaseName;
};

Generator.prototype.getBlockFunctionName = function(blockName) {
	return this.blockFunctionNamePrefixStr + strTools.capFirst(blockName);
};

Generator.prototype.createBuffer = function() {
	return new Buffer();
};

Generator.prototype.appendToStack = function(obj) {
	this.stack.push(obj);
	this.currentBuffer = null;
};

Generator.prototype.appendBuffer = function() {
	var buffer = this.createBuffer();
	this.appendToStack(buffer);
	return buffer;
};

Generator.prototype.appendLineNumberTo = function(buffer, ctx) {
	buffer.append(' // @', ctx.lineNumber, ':', ctx.linePos);
};

Generator.prototype.removeTrailingSpaces = function(code) {
	return code.replace(/[\ \t]+$/g, '');
};

Generator.prototype.compactFragmentWhitespaces = function(fragment) {
	// NOTE keep in mind that html can contain not only text and tags but also script blocks
	return fragment
				   .replace(/\s*[\r\n]+\s*</g, '<')
				   .replace(/>\s*[\r\n]+\s*/g, '>')
				   .replace(/(^\s*[\r\n]\s*)|(\s*[\r\n]\s*$)/g, '');
};
