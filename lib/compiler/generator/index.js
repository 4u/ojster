
/*

TODO

- use defaultsOptions for each option to expose defaults

optimize:
- pre-concat sequential string constants

*/

var Block = require('./block');
var Buffer = require('./buffer');
var tokens = require('../tokenizer/tokens');
var generationErrors = require('./generation_errors');

var strTools = require('../../tools/str_tools');
var objectTools = require('../../tools/object_tools');

var Generator = function(options, errors) {
    options = options || {};

    this.needCompactFragmentWhitespaces =
        options.compactFragmentWhitespaces === undefined ? true : options.compactFragmentWhitespaces;

    this.intro = options.intro === undefined ? Generator.defaultOptions.intro : options.intro;

    this.thisAlias = options.thisAlias || 'self';

    this.inheritsAlias = options.inheritsAlias || 'inherits';
    this.inheritsPath = options.inheritsPath || "'util'";
    this.inheritsSubpath = options.inheritsSubpath || 'inherits';
    this.inheritsFullName = options.inheritsFullName;

    this.indentStr = options.indentStr || '\t';
    this.appendFunctionStr = options.appendFunctionStr || 'writer.write';
    this.escapeFunctionStr = options.escapeFunctionStr || 'escape';

    this.blockFunctionNamePrefixStr = options.blockFunctionNamePrefixStr || 'renderBlock';

	this.blockLocals = options.blockLocals || Generator.defaultOptions.blockLocals;

    this.nonBlockFragmentsAreCode =
        options.nonBlockFragmentsAreCode === undefined ? true : options.nonBlockFragmentsAreCode;

    if (options.appendLineNumbers !== undefined && !options.appendLineNumbers) {
        this.appendLineNumbersFor = {};
    } else {
        this.appendLineNumbersFor = objectTools.extend({
            require: false,
            template: false,
            inherits: false,
            block: true,
            blockClose: true,
            blockCall: true,
            fragment: false,
            expression: true,
            sequenceClose: true,
            sequenceCloseBeforeBlockClose: false,
            oneLineCodeFragment: false
        }, options.appendLineNumbersFor);
    }

    this.errors = errors;

    this.templateAlias = null;
    this.templateFullName = null;
    this.templateNameToUse = null;

    this.templateBaseName = null;
	this.templateBaseFullName = null;
    this.templateBaseNameToUse = null;

    this.stack = [];
    this.currentBuffer = null;

    this.blockStack = [];
    this.currentBlock = null;

    this.requireInheritsBuffer = null;
    this.definitionBuffer = null;
    this.definitionCtx = null;

    this.templateInfoSet = false;
    this.inheritsAdded = false;
	this.usedBlockNames = {};

    this.requirements = [];

	this.templateInfoMissedErrorReported = false;

    this.initStack();
};

module.exports = Generator;

Generator.errors = generationErrors;

Generator.defaultOptions = {
	intro: '// Content below is autogenerated by ojster template engine\n// usually there is no reason to edit it manually\n',
	blockLocals: 'var d = this.data, vars = this.vars;'
};

Generator.prototype.error = function(err) {
    this.errors.push(err);
};

Generator.prototype.initStack = function() {
	this.appendIntro();
    this.requireInheritsBuffer = this.appendBuffer();
};

Generator.prototype.applyToken = function(token) {
    token.generatorAction(this);
};

Generator.prototype.appendIntro = function() {
	if (this.intro) {
	    this.append(this.intro);
	}
};

Generator.prototype.appendRequire = function(ctx, alias, path, subpath, fullName, subname) {
	if (this.currentBlock) {
		this.error(new generationErrors.RequireWithinBlock(ctx));
		return;
	}

    this.appendRequireTo(this, ctx, alias, path, subpath, fullName);
    this.requirements.push({
		alias: alias,
		path: path,
		subpath: subpath,
		fullName: fullName,
		subname: subname
	});
};

Generator.prototype.appendRequireTo = function(buffer, ctx, alias, path, subpath, fullName) {
    buffer.append(
        'var ', alias, ' = require(', path, ')'
    );
    if (subpath) {
        buffer.append(
            '.', subpath
        );
    }
    buffer.append(';');

    if (ctx && this.appendLineNumbersFor.require) {
        this.appendLineNumberTo(buffer, ctx);
    }
};

Generator.prototype.appendInheritsRequire = function() {
    this.requireInheritsBuffer.append('\n');
    this.appendRequireTo(this.requireInheritsBuffer, null,
        this.inheritsAlias,
        this.inheritsPath,
        this.inheritsSubpath,
        this.inheritsFullName
    );
    this.requireInheritsBuffer.append('\n');
};

Generator.prototype.setTemplateInfo = function(ctx, templateAlias, templateFullName) {
	if (this.currentBlock) {
		this.error(new generationErrors.TemplateInfoWithinBlock(ctx));
		return;
	}
	if (this.templateInfoSet) {
		this.error(new generationErrors.DuplicateTemplateInfo(ctx));
		return;
	}

    this.templateAlias = templateAlias;
    this.templateFullName = templateFullName;
	this.templateNameToUse = this.getTemplateNameToUse();
    this.appendDefinitionBuffer();
    this.definitionCtx = ctx;

	this.templateInfoSet = true;
};

Generator.prototype.appendDefinitionBuffer = function() {
    this.definitionBuffer = this.appendBuffer();
};

Generator.prototype.setInheritanceInfo = function(ctx, templateBaseName, templateBaseFullName) {
	if (this.currentBlock) {
		this.error(new generationErrors.InheritanceInfoWithinBlock(ctx));
		return;
	}
	if (this.inheritsAdded) {
		this.error(new generationErrors.DuplicateInheritanceInfo(ctx));
		return;
	}
	if (!this.templateInfoSet) {
		if (!this.templateInfoMissedErrorReported) {
			this.error(new generationErrors.TemplateInfoMissed());
			this.templateInfoMissedErrorReported = true;
		}
		return;
	}

    this.templateBaseName = templateBaseName;
	this.templateBaseFullName = templateBaseFullName;
	this.templateBaseNameToUse = this.getTemplateBaseNameToUse();
    this.appendInheritsRequire();
    this.appendInherits(ctx);
    this.inheritsAdded = true;
};

Generator.prototype.appendFragment = function(ctx, fragment) {
    if (!fragment) {
        return;
    }

    if (!this.currentBlock) {
        if (this.nonBlockFragmentsAreCode) {
            this.appendCodeFragment(ctx, fragment, true);
            return;
        }

        if (!fragment.match(/\S/)) {
            return;
        }

		this.error(new generationErrors.FragmentBeyondBlock(ctx));
		return;
    }

    if (this.needCompactFragmentWhitespaces) {
        fragment = this.compactFragmentWhitespaces(fragment);
		if (!fragment) {
			return;
		}
    }

    this.appendToSequence("'", strTools.jsStringEscape(fragment), "'");

    this.lastSequenceCtx = this.appendLineNumbersFor.fragment ? ctx : null;
};

Generator.prototype.appendExpression = function(ctx, expression, toBeEscaped) {
	if (!this.currentBlock) {
		this.error(new generationErrors.ExpressionBeyondBlock(ctx));
		return;
	}

    if (expression.search(/[\r\n]/) == -1) {
        expression = expression.trim();
    }

    if (toBeEscaped) {
        this.appendToSequence(this.thisAlias, '.', this.escapeFunctionStr, '(', expression, ')');
    } else {
        this.appendToSequence(expression);
    }

    this.lastSequenceCtx = this.appendLineNumbersFor.expression ? ctx : null;
};

Generator.prototype.appendCodeFragment = function(ctx, code, fragmentAsCode) {
    if (this.currentBlock && !code.match(/\S/)) {
        return;
    }

    var buffer;
    if (this.currentBlock) {
        this.closeSequenceIfNeed(ctx);
        buffer = this.currentBlock;
    } else {
        buffer = this;
    }

    var oneLineInstruction = (!fragmentAsCode && code.search(/[\r\n]/) == -1);
    if (oneLineInstruction) {
        code = code.trim();
        if (this.currentBlock) {
            buffer.append('\n', this.indentStr);
        }
    } else if (!fragmentAsCode) {
		code = this.removeTrailingSpaces(code);
	}

    buffer.append(code);

    if (this.currentBlock) {
        if (oneLineInstruction) {
            if (ctx && this.appendLineNumbersFor.oneLineCodeFragment) {
                this.appendLineNumberTo(buffer, ctx);
            }
            buffer.append('\n');
        }
        buffer.append('\n');
    }

};

Generator.prototype.openBlock = function(ctx, blockName, blockArgs, closeImmediately) {
	if (blockName in this.usedBlockNames) {
		this.error(new generationErrors.DuplicateBlockName(ctx, blockName));
		return;
	}

    var buffer = this.createBuffer();
    var block = new Block(blockName, blockArgs, buffer);

    if (this.currentBlock) {
        this.appendBlockCall(ctx, blockName, blockArgs);
    }

    this.blockStack.push(block);
    this.currentBlock = block;

    this.appendToStack(block);

    this.appendBlockDefinitionStart(ctx);

    if (closeImmediately) {
        this.closeBlock(null, blockName);
    }

	this.usedBlockNames[blockName] = true;
};

Generator.prototype.closeBlock = function(ctx, blockName) {
	if (this.currentBlock == null || blockName != null && this.currentBlock.name != blockName) {
		this.error(new generationErrors.BlockOpeningMissed(ctx, blockName));
		return;
	}

    this.closeSequenceIfNeed(this.appendLineNumbersFor.sequenceCloseBeforeBlockClose ? ctx : null);
    this.appendBlockDefinitionEnd(ctx);

    this.blockStack.pop();
    this.currentBlock = this.blockStack[this.blockStack.length - 1];
};

Generator.prototype.appendToSequence = function() {
    this.openSequenceOrSeparateIfNeed();
    this.currentBlock.append.apply(this.currentBlock, arguments);
    this.currentBlock.sequenceEmpty = false;
};

Generator.prototype.appendBlockCall = function(ctx, blockName, args) {
	if (!args) {
		args = '';
	}

    this.closeSequenceIfNeed(ctx);
    this.currentBlock.append(this.indentStr, this.thisAlias, '.', this.getBlockFunctionName(blockName), '(', args, ');');

    if (ctx && this.appendLineNumbersFor.blockCall) {
        this.appendLineNumberTo(this.currentBlock, ctx);
    }

    this.currentBlock.append('\n');
};

Generator.prototype.append = function() {
    if (this.currentBuffer == null) {
        this.currentBuffer = this.appendBuffer();
    }
    this.currentBuffer.append.apply(this.currentBuffer, arguments);
};

Generator.prototype.appendMissing = function() {
	if (!this.templateInfoSet) {
		if (!this.templateInfoMissedErrorReported) {
			this.error(new generationErrors.TemplateInfoMissed());
			this.templateInfoMissedErrorReported = true;
		}
		return;
	}
	if (!this.inheritsAdded) {
		this.error(new generationErrors.InheritanceInfoMissed());
		return;
	}

    this.appendDefinition();
    this.appendExports();
};

Generator.prototype.getResult = function() {
    this.appendMissing();
    this.append('\n'); // trailing \n

    var result = [];

    for (var i=0, l=this.stack.length; i<l; i++) {
        var item = this.stack[i];
        result.push(item.getValue());
    }

    return result.join('');
};

Generator.prototype.openSequenceOrSeparateIfNeed = function() {
    if (!this.currentBlock.sequenceOpened) {
        this.openSequence();
        this.currentBlock.sequenceOpened = true;
        this.currentBlock.sequenceEmpty = true;
    } else if (!this.currentBlock.sequenceEmpty) {
        this.separateSequence();
    }
};

Generator.prototype.closeSequenceIfNeed = function(ctx) {
    if (this.currentBlock.sequenceOpened) {
        this.closeSequence(ctx);
        this.currentBlock.sequenceOpened = false;
    }
};

Generator.prototype.appendDefinition = function() {
    this.definitionBuffer.append(
		'/** @constructor */\n', // need it to prevent warning in some linters
        'var ', this.templateNameToUse, ' = function() {'
    );

    if (this.definitionCtx && this.appendLineNumbersFor.template) {
        this.appendLineNumberTo(this.definitionBuffer, this.definitionCtx);
    }

    this.definitionBuffer.append(
        '\n',
        this.indentStr
    );
    this.appendSuperClassConstructorCall();
    this.definitionBuffer.append(
        '\n};'
    );
};

Generator.prototype.appendSuperClassConstructorCall = function() {
    this.definitionBuffer.append(
        this.templateBaseNameToUse, '.apply(this, arguments);'
    );
};

Generator.prototype.appendInherits = function(ctx) {
    this.append(
        this.inheritsAlias, '(', this.templateNameToUse, ', ', this.templateBaseNameToUse, ');'
    );

    if (ctx && this.appendLineNumbersFor.inherits) {
        this.appendLineNumberTo(this, ctx);
    }
};

Generator.prototype.appendExports = function() {
    this.append(
        '\nmodule.exports = ', this.templateNameToUse, ';'
    );
};

Generator.prototype.openSequence = function() {
    this.currentBlock.append(
        this.indentStr, this.thisAlias, '.', this.appendFunctionStr, '(\n',
        this.indentStr, this.indentStr
    );
};

Generator.prototype.separateSequence = function() {
    this.currentBlock.append(',');

    if (this.lastSequenceCtx) {
        this.appendLineNumberTo(this.currentBlock, this.lastSequenceCtx);
    }

    this.currentBlock.append(
        '\n',
        this.indentStr, this.indentStr
    );
};

Generator.prototype.closeSequence = function(ctx) {
    if (this.lastSequenceCtx) {
        this.appendLineNumberTo(this.currentBlock, this.lastSequenceCtx);
    }

    this.currentBlock.append(
        '\n',
        this.indentStr, ');'
    );

    if (ctx && this.appendLineNumbersFor.sequenceClose) {
        this.appendLineNumberTo(this.currentBlock, ctx);
    }

    this.currentBlock.append('\n');
};

Generator.prototype.appendBlockDefinitionStart = function(ctx) {
	if (!this.templateInfoSet) {
		if (!this.templateInfoMissedErrorReported) {
			this.error(new generationErrors.TemplateInfoMissed(ctx));
			this.templateInfoMissedErrorReported = true;
		}
		return;
	}

    if (this.blockStack.length > 1) {
        this.currentBlock.append('\n\n');
    }

	var blockArgs = this.currentBlock.args;
	if (!blockArgs) {
		blockArgs = '';
	}
    this.currentBlock.append(
        this.templateNameToUse, '.prototype.', this.getBlockFunctionName(this.currentBlock.name),
        ' = function(', blockArgs, ') {'
    );

    if (ctx && this.appendLineNumbersFor.block) {
        this.appendLineNumberTo(this.currentBlock, ctx);
    }

    this.currentBlock.append('\n');

	this.appendBlockLocals();
};

Generator.prototype.appendBlockLocals = function() {
	if (this.thisAlias && this.thisAlias != 'this') {
		this.currentBlock.append(this.indentStr, 'var ', this.thisAlias, ' = this;\n');
	}
	if (this.blockLocals) {
		this.currentBlock.append(this.indentStr, this.blockLocals, '\n');
	}
};

Generator.prototype.appendBlockDefinitionEnd = function(ctx) {
    this.currentBlock.append('};');

    if (ctx && this.appendLineNumbersFor.blockClose) {
        this.appendLineNumberTo(this.currentBlock, ctx);
    }
};

Generator.prototype.getTemplateNameToUse = function() {
    return this.templateAlias;
};

Generator.prototype.getTemplateBaseNameToUse = function() {
	return this.templateBaseName;
};

Generator.prototype.getBlockFunctionName = function(blockName) {
    return this.blockFunctionNamePrefixStr + strTools.capFirst(blockName);
};

Generator.prototype.createBuffer = function() {
    return new Buffer();
};

Generator.prototype.appendToStack = function(obj) {
    this.stack.push(obj);
    this.currentBuffer = null;
};

Generator.prototype.appendBuffer = function() {
    var buffer = this.createBuffer();
    this.appendToStack(buffer);
    return buffer;
};

Generator.prototype.appendLineNumberTo = function(buffer, ctx) {
    buffer.append(' // @', ctx.lineNumber, ':', ctx.linePos);
};

Generator.prototype.removeTrailingSpaces = function(code) {
	return code.replace(/[\ \t]+$/g, '');
};

Generator.prototype.compactFragmentWhitespaces = function(fragment) {
	// NOTE keep in mind that html can contain not only text and tags but also script blocks
    return fragment
                   .replace(/\s*[\r\n]+\s*</g, '<')
                   .replace(/>\s*[\r\n]+\s*/g, '>')
                   .replace(/(^\s*[\r\n]\s*)|(\s*[\r\n]\s*$)/g, '');
};

Generator.prototype.getPathFromFullName = function(fullName) {
    var items = fullName.split('.');

    for(var i=0, l=items.length; i < l; i++) {
        items[i] = strTools.camelCaseToUnderscore(items[i]);
    }

    return "'" + items.join('/') + "'";
};
